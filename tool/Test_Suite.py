import cv2 
from matplotlib import pyplot as plt 
import numpy
import sys
import math
from nistrng import *
from NIST_Tests import *

#----------------HELPER FUNCTIONS-----------------------#
# Defining helper functions for our unsigned interpretation
def limit_pack(sequence: numpy.ndarray) -> numpy.ndarray:
    """
    Pack a sequence of signed integers to its binary 8-bit representation using numpy.

    :param sequence: the integer sequence to pack (in the form of a numpy array, ndarray)
    :return: the sequence packed in 8-bit integer in the form of a numpy array (ndarray)
    """
    limit = 128

    return numpy.array([1 if element > limit else 0 for element in sequence])

def unpack_sequence(sequence_binary_encoded: numpy.ndarray) -> numpy.ndarray:
    """
    Unpack a sequence of numbers represented with 8-bits to its signed integer representation using numpy.

    :param sequence_binary_encoded: the 8-bit numbers sequence to unpack (in the form of a numpy array, ndarray)
    :return: the sequence unpacked in signed integer in the form of a numpy array (ndarray)
    """
    return numpy.packbits(numpy.array(sequence_binary_encoded)).astype(numpy.uint8)


if __name__ == "__main__":
    #------------Importing Images----------------------------#
    img = cv2.imread('lax_decrypted.jpg', cv2.IMREAD_GRAYSCALE) 
    img2 = cv2.imread('lax_encrypted.jpg', cv2.IMREAD_GRAYSCALE)

    #------------Importing Random Sequences------------------#
    # Import data into a numpy
    random_data = numpy.fromfile('random_sequence.bin', dtype=numpy.uint8)
    random_data_bin = pack_sequence(random_data)
    permute_data = numpy.fromfile('permute_sequence.bin', dtype=numpy.uint8)
    permute_data_bin = pack_sequence(permute_data)
    
    #-----------Plotting Random Sequence--------------------#
    fig2, ax2s = plt.subplots(1, 2, figsize=(10, 4))
    # Plot histogram for Dataset 1
    ax2s[0].hist(random_data, bins=50, alpha=0.5, rwidth=1)
    ax2s[0].set_title('Random Data')
    ax2s[0].set_xlabel('Pixel Value')
    ax2s[0].set_ylabel('Frequency')
    ax2s[0].set_ylim(0, 5000)  # Set y-axis limits for the first subplot
    # Plot histogram for Dataset 2
    ax2s[1].hist(permute_data, bins=50, alpha=0.5, rwidth=1)
    ax2s[1].set_title('Permuted Image')
    ax2s[1].set_xlabel('Pixel Value')
    ax2s[1].set_ylabel('Frequency')
    ax2s[1].set_ylim(0, 5000)  # Set y-axis limits for the first subplot
    
    #------------Plotting the Image Histogram----------------#
    # Set up the figure and axes
    fig, axs = plt.subplots(1, 2, figsize=(10, 4))
    # Plot histogram for Dataset 1
    axs[0].hist(img, bins=30, alpha=0.5, rwidth=1)
    axs[0].set_title('Unencrypted Image')
    axs[0].set_xlabel('Grayscale Pixel Value')
    axs[0].set_ylabel('Frequency')
    axs[0].set_ylim(0, 120)  # Set y-axis limits for the first subplot
    # Plot histogram for Dataset 2
    axs[1].hist(img2, bins=30, alpha=0.5, rwidth=1)
    axs[1].set_title('Encrypted Image')
    axs[1].set_xlabel('Grayscale Pixel Value')
    axs[1].set_ylabel('Frequency')
    axs[1].set_ylim(0, 100)  # Set y-axis limits for the first subplot
    # Adjust layout to prevent overlapping
    plt.tight_layout()
    # Show the plot
    plt.show()
    
    # Generate the sequence of integers and pack it in its 8-bit representation (TEST ONLY)
    sequence: numpy.ndarray = numpy.random.randint(0, 256, 256*256, dtype=int)
    
    # Flatten the image
    flat_img = img.flatten()
    #binary_sequence = limit_pack(flat_img)
    binary_sequence: numpy.ndarray = pack_sequence(flat_img)    
    #plt.stem(binary_sequence, use_line_collection=True)    
    #plt.xlim(0, 100)
    
    # Print sequence
    print("Random sequence generated by Image Encryption:")
    print(flat_img)
    print("Random sequence generated by NumPy encoded in 8-bit signed format:")
    print(binary_sequence)    
    
    #----------------NIST Testing on Encrypted Image ----------------------#
    print("----------------NIST Testing on Encrypted Image-----------------")
    results = []
    results.append(monobit(numpy.copy(binary_sequence)))
    results.append(FrequencyWithinBlock(numpy.copy(binary_sequence)))
    results.append(Runs(numpy.copy(binary_sequence)))
    results.append(dft(numpy.copy(binary_sequence)))
    results.append(binary_matrix_rank(numpy.copy(binary_sequence)))
    results.append(non_overlapping_match(numpy.copy(binary_sequence)))
    #results.append(overlapping_matching(binary_sequence)) #Not Statistically Relevant
    #results.append(maurers_universal(numpy.copy(binary_sequence))) #Not Statistically Relevant
    #results.append(linear_complexity(binary_sequence)) #Not Statistically Relevant
    results.append(serial(numpy.copy(numpy.copy(binary_sequence))))
    results.append(approximate_entropy(numpy.copy(binary_sequence)))
    results.append(cumulative_sum(numpy.copy(binary_sequence)))
    #results.append(random_excursion(numpy.copy(binary_sequence))) #Not Statistically Relevant
    #results.append(random_excursion_variant(numpy.copy(binary_sequence))) #Not Statistically Relevant
        
    for result in results:
        if result[1] == True:
            print("- PASSED - score: " + str(result[2]) + " - " + str(result[0]) + " - elapsed time: " + str(numpy.round(result[3], 3)) + " ms")
        else:
            print("- FAILED - score: " + str(result[2]) + " - " + str(result[0]) + " - elapsed time: " + str(numpy.round(result[3], 3)) + " ms")
    
    #---------------ENTROPY CALCULATION---------------------#
    print("----------------Entropy of Encrypted Image-----------------")

    marg = numpy.histogramdd(numpy.ravel(img), bins = 256)[0]/img.size
    marg = list(filter(lambda p: p > 0, numpy.ravel(marg)))
    entropy = -numpy.sum(numpy.multiply(marg, numpy.log2(marg)))
    print("Entropy is: ", entropy)
    
    #--------------KEY SENSITIVITY ANALYSIS-------------------#
    print("----------------Key Sensitivity Analysis-----------------")
    # Compute the Mean Squared Error (MSE)
    # mse = numpy.sum((img - img2) ** 2) / float(img.size)
    mse = numpy.mean((img - img2)**2)
 
    # If you want to get the PSNR (Peak Signal-to-Noise Ratio) as well
    psnr = 10 * numpy.log10((255 ** 2) / mse)
    
    print(f"Mean Squared Error (MSE): {mse}")
    print(f"Peak Signal-to-Noise Ratio (PSNR): {psnr} dB")
    
    #--------------KEY SENSITIVITY ANALYSIS-------------------#
    print("----------------NIST Testing on Random Skew Tent-----------------")
    results2 = []
    results2.append(monobit(numpy.copy(random_data_bin)))
    results2.append(FrequencyWithinBlock(numpy.copy(random_data_bin)))
    results2.append(Runs(numpy.copy(random_data_bin)))
    results2.append(dft(numpy.copy(random_data_bin)))
    results2.append(binary_matrix_rank(numpy.copy(random_data_bin)))
    results2.append(non_overlapping_match(numpy.copy(random_data_bin)))
    #results2.append(overlapping_matching(random_data_bin)) #Not Statistically Relevant
    #results2.append(maurers_universal(numpy.copy(random_data_bin))) #Not Statistically Relevant
    #results2.append(linear_complexity(random_data_bin)) #Not Statistically Relevant
    results2.append(serial(numpy.copy(numpy.copy(random_data_bin))))
    results2.append(approximate_entropy(numpy.copy(random_data_bin)))
    results2.append(cumulative_sum(numpy.copy(random_data_bin)))
    #results2.append(random_excursion(numpy.copy(random_data_bin))) #Not Statistically Relevant
    #results2.append(random_excursion_variant(numpy.copy(random_data_bin))) #Not Statistically Relevant
       
    for result in results2:
        if result[1] == True:
            print("- PASSED - score: " + str(result[2]) + " - " + str(result[0]) + " - elapsed time: " + str(numpy.round(result[3], 3)) + " ms")
        else:
            print("- FAILED - score: " + str(result[2]) + " - " + str(result[0]) + " - elapsed time: " + str(numpy.round(result[3], 3)) + " ms")
    """